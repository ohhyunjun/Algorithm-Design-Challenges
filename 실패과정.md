# Street Development 문제 - 세 가지 대표 풀이 방식

---

## 1. 이분 탐색 + 그리디

### 핵심 아이디어
- 배터리 용량(B)을 이분 탐색으로 결정한다.
- 각 두 로봇 사이 거리가 B 이내인지 그리디하게 판정한다.
- 모든 정보를 한 지점에 모을 수 있으면 B를 더 줄이고, 안 되면 B를 키운다.

### 코드 예시
```python
def can_cover(B):
    total = 0
    for i in range(n - 1):
        gap = positions[i+1] - positions[i]
        total += max(0, gap - B)
    return total <= B

low, high = 0, L
while low < high:
    mid = (low + high) // 2
    if can_cover(mid):
        high = mid
    else:
        low = mid + 1

print(low)
```

### 장점/특징
- **O(N log L)**로 매우 빠름.
- 케이스가 커도 강력하다.
- 가장 일반적이고 실전에서 널리 쓰임.

---

## 2. MST(최소 신장 트리, 크루스칼)

### 핵심 아이디어
- 각 지점을 노드로 보고, 인접한 쌍의 거리로 MST(최소 신장 트리)를 만든다.
- MST의 **가장 긴 간선**이 이 문제의 최대 이동 거리(최악의 상황)다.
- 최대 간선을 양쪽 로봇이 만나는 상황이므로, 이를 2로 나눈 값이 정답.

### 코드 예시
```python
def minimum_battery_mst(positions):
    n = len(positions)
    edges = []
    for i in range(n - 1):
        dist = positions[i+1] - positions[i]
        edges.append((dist, i, i+1))
    edges.sort()
    parent = list(range(n))
    max_edge_in_mst = 0
    count = 0
    for cost, a, b in edges:
        if find_parent(parent, a) != find_parent(parent, b):
            union(parent, a, b)
            max_edge_in_mst = max(max_edge_in_mst, cost)
            count += 1
            if count == n - 1:
                break
    return (max_edge_in_mst + 1) // 2 if max_edge_in_mst % 2 == 1 else max_edge_in_mst // 2
```

### 장점/특징
- **그래프 해석이 직관적**이고 구조적 의미를 알기 좋다.
- MST 특성상, "최적의 연결 구조"가 자동으로 나온다.

---

## 3. 릴레이(투 포인터, 중간전달)

### 핵심 아이디어
- 각 로봇이 자신의 배터리로 안쪽으로 최대한 진입(릴레이 이동).
- 왼쪽/오른쪽 로봇이 중앙에서 겹치거나 교차하는 순간 정보가 모두 통합됨.
- 중간 로봇들이 정보 중계(릴레이) 역할을 하므로 현실적인 이동 시뮬레이션에 강하다.

### 코드 예시
```python
def can_relay(positions, B):
    left = positions[0] + B
    right = positions[-1] - B
    if left >= right:
        return True
    i, j = 1, len(positions) - 2
    while i <= j:
        cost = abs(positions[i] - left)
        if cost > B:
            return False
        left += (B - cost)
        if left >= right:
            return True
        cost = abs(positions[j] - right)
        if cost > B:
            return False
        right -= (B - cost)
        if left >= right:
            return True
        i += 1
        j -= 1
    return left >= right

def find_min_B(positions):
    positions = sorted(positions)
    max_gap = positions[-1] - positions[0]
    for B in range(max_gap + 1):
        if can_relay(positions, B):
            return B
    return None
```

### 장점/특징
- 현실의 "정보 릴레이" 방식에 가장 가까움.
- 중간에서 만나는 방식이나 양방향 통합도 자연스럽게 구현.
- 브루트포스면 느릴 수 있으나, 이분 탐색 결합하면 효율적(O(N log D)).

---

## 세 가지 방식 비교

| 방식               | 아이디어                    | 장점                                   | 한계/특징                       |
|--------------------|----------------------------|----------------------------------------|----------------------------------|
| 이분탐색+그리디    | 최대 이동거리 탐색          | 빠르고 직관적, 대형 케이스 강함        | 한 지점 모으기만 최적            |
| MST(크루스칼)      | 그래프 최적 연결            | 구조적, 연결의 최적성 보장             | 간선 정의와 구현이 다소 복잡      |
| 릴레이(투 포인터)  | 중간전달·릴레이 교차        | 현실적, 릴레이 및 분산 전달 모두 가능   | 브루트포스는 느림, 이분탐색 추천  |

---

## 결론 및 요약

- **이분탐색+그리디** : 가장 보편적, 실제 대회나 대형 데이터에 최적화.
- **MST(크루스칼)** : 연결 구조 분석이나 거리 그래프 해석에 적합.
- **릴레이(투 포인터)** : 현실 릴레이/분산상황에 대한 직관적 시뮬레이션이 필요할 때 강력.

상황과 입력 크기에 따라 최적 방식을 선택하면 됩니다.
