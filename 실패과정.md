## 1. 핵심 아이디어

- **가장 왼쪽 로봇과 오른쪽 로봇**이 각각 바깥쪽에서 안쪽으로 이동하며,
- 각자 **최대한 자신의 배터리를 써서 중앙을 향해 진입**.
- "왼쪽 진영"과 "오른쪽 진영"이 **교차하거나 겹치는 순간** 정보가 모두 모임.
- **한 번에 모두 모이지 않아도 릴레이(중간 전달)가 가능**한지 판단.
### (1) `can_relay(positions, B)`
```python
# 입력 받기
L, n = map(int, input().split())
positions = list(map(int, input().split()))
positions.sort()

# 배터리 B로 가능한지 검사하는 함수
def can_cover(B):
    total = 0
    for i in range(n - 1):
        gap = positions[i+1] - positions[i]
        total += max(0, gap - B)
    return total <= B

# 이진 탐색으로 최소 B 찾기
low, high = 0, L
while low < high:
    mid = (low + high) // 2
    if can_cover(mid):
        high = mid
    else:
        low = mid + 1

# 결과 출력
print(low)
```
- **입력**:  
  - `positions`: 정렬된 로봇 위치 리스트  
  - `B`: 각 로봇의 배터리 용량

- **과정 요약**:  
  1. **왼쪽 로봇**은 `positions[0] + B`까지,  
     **오른쪽 로봇**은 `positions[-1] - B`까지 한 번에 전진.
  2. 만약 이 두 범위가 이미 겹치면 바로 성공.
  3. 아니라면 **두 번째 왼쪽(i)와 두 번째 오른쪽(j) 로봇**이
     - 자신 위치에서 각각 left, right까지 이동한 뒤,
     - 남은 배터리로 중앙을 향해 추가 진입.
  4. 양쪽이 만나는지 반복 체크.
  5. 한쪽이라도 배터리가 모자라면 False.

- **릴레이의 의미**:
  - 한 번에 중앙으로 모이지 못해도, **중간에 정보 넘기며 점진적 합류**가 가능.
